[
  {
    "path": "components/admin/ActivationPage.tsx",
    "content": "\n\n\n\nimport React, { useState } from 'react';\nimport type { UserProfile, Page, UserStatus } from '../../types';\nimport { Button } from '../ui/Button';\nimport { Card } from '../ui/Card';\n\ninterface ActivationPageProps {\n  users: UserProfile[];\n  onUpdateUser: (userId: string, status: UserStatus) => Promise<void>;\n  onNavigate: (page: Page) => void;\n}\n\nexport const ActivationPage: React.FC<ActivationPageProps> = ({ users, onUpdateUser, onNavigate }) => {\n  const pendingUsers = users.filter(u => u.status === 'aguardando_ativacao');\n  const [updatingUserId, setUpdatingUserId] = useState<string | null>(null);\n\n  const handleActivate = async (userId: string, status: UserStatus) => {\n    setUpdatingUserId(userId);\n    try {\n        await onUpdateUser(userId, status);\n    } catch (error) {\n        console.error(\"Failed to activate user:\", error);\n    } finally {\n        // The component will re-render without this user, so we don't strictly need to nullify,\n        // but it's good practice in case of an error where the user remains.\n        setUpdatingUserId(null);\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-100 p-4 sm:p-6 lg:p-8\">\n      <header className=\"max-w-7xl mx-auto mb-8 flex justify-between items-center\">\n        <div>\n          <h1 className=\"text-3xl font-bold text-gray-800\">Ativação de Contas</h1>\n          <p className=\"text-gray-600\">Ative novas contas de usuários com um plano específico.</p>\n        </div>\n        <div className=\"flex space-x-2\">\n            <Button onClick={() => onNavigate('admin-users')} variant=\"secondary\">Gestão de Usuários</Button>\n            <Button onClick={() => onNavigate('dashboard')}>Dashboard</Button>\n        </div>\n      </header>\n      <main className=\"max-w-7xl mx-auto\">\n        <Card>\n          <div className=\"overflow-x-auto\">\n            <table className=\"min-w-full divide-y divide-gray-200\">\n              <thead className=\"bg-gray-50\">\n                <tr>\n                  <th scope=\"col\" className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">Email</th>\n                  <th scope=\"col\" className=\"px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">Ações</th>\n                </tr>\n              </thead>\n              <tbody className=\"bg-white divide-y divide-gray-200\">\n                {pendingUsers.length > 0 ? pendingUsers.map(user => (\n                  <tr key={user.id}>\n                    <td className=\"px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900\">{user.email}</td>\n                    <td className=\"px-6 py-4 whitespace-nowrap text-sm font-medium\">\n                      {updatingUserId === user.id ? (\n                        <div className=\"flex items-center text-gray-500 text-xs\">\n                           <svg className=\"animate-spin mr-2 h-4 w-4 text-gray-400\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                                <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                                <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                            </svg>\n                          Ativando...\n                        </div>\n                      ) : (\n                        <div className=\"space-x-2\">\n                            <Button onClick={() => handleActivate(user.id, 'ativa_free')} variant=\"secondary\" className=\"py-1 px-3 text-xs bg-green-200 text-green-800 hover:bg-green-300\">Ativar FREE</Button>\n                            <Button onClick={() => handleActivate(user.id, 'ativa_starter')} variant=\"secondary\" className=\"py-1 px-3 text-xs bg-blue-200 text-blue-800 hover:bg-blue-300\">Ativar STARTER</Button>\n                            <Button onClick={() => handleActivate(user.id, 'ativa_pro')} variant=\"secondary\" className=\"py-1 px-3 text-xs bg-indigo-200 text-indigo-800 hover:bg-indigo-300\">Ativar PRO</Button>\n                            <Button onClick={() => handleActivate(user.id, 'ativa_premium')} variant=\"success\" className=\"py-1 px-3 text-xs\">Ativar PREMIUM</Button>\n                        </div>\n                      )}\n                    </td>\n                  </tr>\n                )) : (\n                    <tr>\n                        <td colSpan={2} className=\"px-6 py-4 text-center text-gray-500\">\n                            Nenhum usuário aguardando ativação.\n                        </td>\n                    </tr>\n                )}\n              </tbody>\n            </table>\n          </div>\n        </Card>\n      </main>\n    </div>\n  );\n};"
  },
  {
    "path": "services/supabase.ts",
    "content": "\nimport { createClient } from '@supabase/supabase-js';\nimport { SUPABASE_URL, SUPABASE_ANON_KEY } from './supabaseConfig';\n\n// Verifica se as credenciais ainda são placeholders.\nexport const isSupabaseConfigured = !(SUPABASE_URL.includes('COLE_AQUI') || SUPABASE_ANON_KEY.includes('COLE_AQUI'));\n\n// Exporta o client. App.tsx é responsável por prevenir o seu uso se não estiver configurado.\n// A criação do client em si é leve e não causa problemas de rede imediatos.\nexport const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);"
  },
  {
    "path": "services/supabaseConfig.ts",
    "content": "\n// Este arquivo armazena as credenciais de conexão do Supabase.\n// Para a validação do MVP, você pode colar suas chaves diretamente aqui.\n\n// =================================================================================\n// ATENÇÃO: INSTRUÇÕES DE CONFIGURAÇÃO PARA O MVP\n// =================================================================================\n// 1. Vá para o seu projeto no Supabase.\n// 2. Encontre suas chaves de API em \"Project Settings\" > \"API\".\n// 3. Copie o valor de \"Project URL\" e cole na constante SUPABASE_URL abaixo.\n// 4. Copie o valor de \"Project API Keys\" (a chave anon public) e cole na SUPABASE_ANON_KEY.\n// =================================================================================\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// ALERTA DE SEGURANÇA: Não envie este arquivo para um repositório público com as\n// chaves preenchidas. Esta abordagem é APENAS para a fase de validação inicial.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nexport const SUPABASE_URL = \"https://nsfbnpyxxhxbitqjzwom.supabase.co\";\nexport const SUPABASE_ANON_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5zZmJucHl4eGh4Yml0cWp6d29tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjExMjcwNjMsImV4cCI6MjA3NjcwMzA2M30.qmYViSOdI0CI8_eveeLH4u14pGMe1P8T1LLMOE19s3E\";"
  },
  {
    "path": "components/ui/LoadingSpinner.tsx",
    "content": "\nimport React from 'react';\n\nexport const LoadingSpinner: React.FC = () => (\n  <div className=\"flex flex-col items-center justify-center\">\n    <svg className=\"animate-spin h-10 w-10 text-indigo-600\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n        <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n        <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n    </svg>\n    <p className=\"mt-4 text-gray-600 text-lg\">Carregando...</p>\n  </div>\n);"
  },
  {
    "path": "index.css",
    "content": "\n/* \n  This file is intentionally almost empty. \n  It exists to prevent a 404 error in browsers with an old cached version of the site \n  that might be trying to load a non-existent index.css file, which was blocking the app from rendering.\n*/"
  },
  {
    "path": "services/geminiConfig.ts",
    "content": "\n// Este arquivo armazena as credenciais de conexão do Google Gemini.\n// Para a validação do MVP, você pode colar sua chave diretamente aqui.\n\n// =================================================================================\n// ATENÇÃO: INSTRUÇÕES DE CONFIGURAÇÃO PARA O MVP\n// =================================================================================\n// 1. Obtenha sua chave de API no Google AI Studio.\n// 2. Cole a chave na constante GEMINI_API_KEY abaixo, substituindo \"COLE_AQUI_SUA_CHAVE_API_DO_GEMINI\".\n// =================================================================================\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// ALERTA DE SEGURANÇA: Não envie este arquivo para um repositório público com as\n// chaves preenchidas. Esta abordagem é APENAS para a fase de validação inicial.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n// FIX: Reverted to a hardcoded key placeholder for the pre-MVP testing phase.\nexport const GEMINI_API_KEY: string = \"AIzaSyCyh43BgOsfCijaBuKIhxHrdEnZhwWON1Q\";\n\n/**\n * Verifica se a chave da API foi alterada do valor placeholder.\n * O App.tsx usará isso para mostrar um erro de configuração se a chave não for fornecida.\n */\n// FIX: Re-enabled the configuration check for the pre-MVP phase.\nexport const isGeminiConfigured = !GEMINI_API_KEY.includes('COLE_AQUI');"
  },
  {
    "path": "vite-env.d.ts",
    "content": "\n// Este arquivo pode ser usado para estender tipos de ambiente,\n// mas com a abordagem de MVP de chaves hardcoded, ele não é mais necessário\n// para definir as variáveis de ambiente."
  },
  {
    "path": "components/ConfigurationErrorPage.tsx",
    "content": "\nimport React from 'react';\nimport { Card } from './ui/Card';\n\ninterface ConfigurationErrorPageProps {\n  // FIX: Re-added 'gemini' to missing keys to support the pre-MVP config check.\n  missingKeys: ('supabase' | 'gemini')[];\n}\n\nconst CodeBlock: React.FC<{ children: React.ReactNode }> = ({ children }) => (\n  <code className=\"bg-gray-200 text-red-700 font-mono p-1 rounded text-sm\">\n    {children}\n  </code>\n);\n\nexport const ConfigurationErrorPage: React.FC<ConfigurationErrorPageProps> = ({ missingKeys }) => {\n  return (\n    <div className=\"min-h-screen bg-red-50 flex flex-col justify-center items-center p-4\">\n      <Card className=\"w-full max-w-2xl border-2 border-red-300\">\n        <h1 className=\"text-2xl font-bold text-red-800 mb-4\">\n          Erro de Configuração Crítico\n        </h1>\n        <p className=\"text-gray-700 mb-6\">\n          A aplicação não pode iniciar porque uma ou mais chaves de API essenciais não foram configuradas.\n          Para resolver isso, por favor edite os seguintes arquivos no seu código:\n        </p>\n        <div className=\"space-y-4\">\n          {missingKeys.includes('supabase') && (\n            <div className=\"bg-red-100 p-4 rounded-lg\">\n              <h2 className=\"font-semibold text-red-900\">Credenciais do Supabase Faltando</h2>\n              <p className=\"mt-1 text-gray-800\">\n                Por favor, adicione sua URL e Chave Anon do Supabase no arquivo:{' '}\n                <CodeBlock>services/supabaseConfig.ts</CodeBlock>\n              </p>\n            </div>\n          )}\n          {/* FIX: Re-added Gemini config error message for the pre-MVP phase. */}\n          {missingKeys.includes('gemini') && (\n            <div className=\"bg-red-100 p-4 rounded-lg\">\n              <h2 className=\"font-semibold text-red-900\">Chave da API do Gemini Faltando</h2>\n              <p className=\"mt-1 text-gray-800\">\n                Por favor, adicione sua chave de API do Google Gemini no arquivo:{' '}\n                <CodeBlock>services/geminiConfig.ts</CodeBlock>\n              </p>\n            </div>\n          )}\n        </div>\n        <p className=\"mt-6 text-sm text-gray-600\">\n          Após adicionar as chaves e salvar os arquivos, a aplicação irá funcionar corretamente.\n          Esta é uma medida de segurança para a fase de MVP, para garantir que você não se esqueça de configurar as chaves.\n        </p>\n      </Card>\n    </div>\n  );\n};"
  },
  {
    "path": "services/pdf-generator.ts",
    "content": ""
  },
  {
    "path": "services/pdf-assets.ts",
    "content": ""
  },
  {
    "path": "api/generate-pdf.ts",
    "content": "\n// Este arquivo foi movido para supabase/functions/generate-pdf/index.ts\n// para seguir a estrutura de pastas exigida pelo Supabase CLI.\n// Este arquivo pode ser excluído."
  },
  {
    "path": "supabase/functions/generate-pdf/index.ts",
    "content": "\n// supabase/functions/generate-pdf/index.ts\n\nimport { encode } from \"https://deno.land/std/encoding/base64.ts\";\n\n// FIX: The original triple-slash directive `/// <reference lib=\"deno.ns\" />` was causing type resolution errors\n// in the local TypeScript environment. The subsequent fix `declare const Deno: any;` was removed because it was\n// causing a \"Cannot redeclare block-scoped variable 'Deno'\" error, indicating that Deno's types are now\n// available in the project's scope, making the declaration redundant.\n\n// Shared CORS headers\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n};\n\nconsole.log('Function \"generate-pdf\" initialized.');\n\nDeno.serve(async (req: Request) => {\n  // Handle CORS preflight requests\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders });\n  }\n\n  try {\n    if (req.method !== 'POST') {\n      throw new Error('Method not allowed');\n    }\n\n    const { html } = await req.json();\n\n    if (!html || typeof html !== 'string') {\n      throw new Error('Missing or invalid \"html\" key in request body');\n    }\n\n    const tempId = crypto.randomUUID();\n    const inputHtmlPath = `/tmp/book-${tempId}.html`;\n    const outputPdfPath = `/tmp/book-${tempId}.pdf`;\n    \n    try {\n      await Deno.writeTextFile(inputHtmlPath, html);\n\n      const command = new Deno.Command(\"weasyprint\", {\n        args: [\n          '--encoding', 'utf8',\n          inputHtmlPath, \n          outputPdfPath\n        ],\n      });\n      const { code, stderr } = await command.output();\n      \n      if (code !== 0) {\n        const errorOutput = new TextDecoder().decode(stderr);\n        console.error('WeasyPrint execution failed:', errorOutput);\n        throw new Error(`WeasyPrint failed: ${errorOutput}`);\n      }\n\n      const pdfBytes = await Deno.readFile(outputPdfPath);\n      \n      // FIX: Changed the response to be a JSON object containing the base64-encoded PDF.\n      // This makes it compatible with the supabase.functions.invoke helper, which expects JSON.\n      const pdfBase64 = encode(pdfBytes);\n      \n      return new Response(JSON.stringify({ pdfBase64 }), {\n        headers: {\n          ...corsHeaders,\n          'Content-Type': 'application/json',\n        },\n        status: 200,\n      });\n    } finally {\n      // Clean up temporary files, ignoring errors if they don't exist\n      await Deno.remove(inputHtmlPath).catch(() => {});\n      await Deno.remove(outputPdfPath).catch(() => {});\n    }\n  } catch (error) {\n    console.error('Error in generate-pdf function:', error);\n    return new Response(JSON.stringify({ error: error.message }), {\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n      status: 400, // Use 400 for client-side errors like bad input\n    });\n  }\n});"
  },
  {
    "path": "services/bookFormatter.ts",
    "content": "\nimport type { Book, BookPart } from '../types';\n\n/**\n * Converte um texto simples com quebras de linha em parágrafos HTML.\n */\nconst formatParagraphs = (text: string): string => {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n  return text.split('\\n')\n    .filter(p => p.trim() !== '')\n    .map(p => `<p class=\"font-merriweather\">${p.trim()}</p>`)\n    .join('\\n');\n};\n\n/**\n * Gera o conteúdo completo da tag <head>, incluindo todos os estilos CSS.\n */\nconst getHeadContent = (book: Book): string => {\n  // Prepara o título para ser usado no CSS, removendo caracteres que podem quebrar a string.\n  const safeTitle = book.title.toUpperCase().replace(/\"/g, \"'\");\n\n  return `\n  <head>\n    <meta charset=\"utf-8\">\n    <title>${book.title}</title>\n    <style>\n      /* --- FONTES --- */\n      @import url('https://fonts.googleapis.com/css2?family=Anton&family=Montserrat:wght@400;700&family=Merriweather:wght@200;300;400;700;800&family=Merriweather+Sans:wght@300;400;600;700;800&display=swap');\n\n      /* ======================================= */\n      /*   SISTEMA DE PÁGINAS MESTRAS            */\n      /* ======================================= */\n\n      /* 1. Página mestre para o CONTEÚDO PADRÃO (com cabeçalho/rodapé) */\n      @page content {\n        size: A5;\n        margin: 25mm 20mm 17mm 20mm;\n\n        @top-center {\n          content: \"${safeTitle}\";\n          font-family: 'Merriweather Sans', sans-serif;\n          font-weight: 300; font-size: 8pt; color: #000080;\n          text-transform: uppercase; vertical-align: middle;\n        }\n        @bottom-center {\n          content: counter(page);\n          font-family: 'Merriweather Sans', sans-serif;\n          font-weight: 800; font-size: 14pt; color: rgba(0, 0, 128, 0.4);\n          vertical-align: middle;\n        }\n      }\n\n      /* 2. EXCEÇÃO para a PRIMEIRA PÁGINA DE UM FLUXO de conteúdo (remove o cabeçalho) */\n      @page content:first {\n        @top-center { content: \"\"; }\n      }\n      \n      /* 3. Regra para a PRIMEIRA PÁGINA DO ARQUIVO (A CAPA), totalmente limpa */\n      @page :first {\n         size: A5;\n         margin: 0; /* A capa não tem margens */\n         @top-center { content: \"\"; }\n         @bottom-center { content: \"\"; }\n      }\n\n      /* --- ESTILOS GERAIS E CONTAINERS --- */\n      body {\n        font-family: 'Merriweather', serif;\n        font-size: 12pt;\n        color: #262626;\n        margin: 0;\n        background-color: #ffffff;\n      }\n      .page-container {\n        width: 100%;\n        margin: 0; padding: 0;\n        background: transparent;\n        box-shadow: none;\n        page-break-after: always;\n      }\n      .content-page {\n        page: content;\n      }\n\n      /* --- ESTILOS DA CAPA --- */\n      .cover-page {\n        width: 14.8cm;\n        height: 21cm;\n        position: relative; \n        overflow: hidden;\n        background-size: cover;\n        background-position: center;\n      }\n      .cover-element {\n        position: absolute;\n        width: 90%;\n        left: 50%;\n        transform: translateX(-50%);\n        text-align: center;\n        padding: 0 1cm;\n        box-sizing: border-box;\n      }\n      .cover-title {\n        top: 40mm;\n        font-family: 'Anton', sans-serif;\n        font-size: 2.8rem;\n        line-height: 1.1;\n        text-transform: uppercase;\n        color: #001f5c;\n      }\n      .cover-subtitle {\n        top: 90mm;\n        font-family: 'Montserrat', sans-serif;\n        font-size: 1.1rem;\n        line-height: 1.6;\n        color: #2b4b8a;\n      }\n      .cover-author {\n        bottom: 45mm; \n        font-family: 'Montserrat', sans-serif;\n        font-weight: 700;\n        font-size: 0.8rem;\n        letter-spacing: 2px;\n        text-transform: uppercase;\n        color: #4a68a5;\n      }\n      .cover-logo {\n        bottom: 20mm;\n        width: auto;\n        height: 25px;\n      }\n\n      /* --- HIERARQUIA TIPOGRÁFICA (ALINHADA À GRADE DE 18pt) --- */\n      .chapter-title-page { \n        display: flex;\n        justify-content: center;\n        align-items: flex-start;\n        text-align: center;\n      }\n      .chapter-title-standalone {\n        font-family: 'Merriweather', serif;\n        font-size: 24pt;\n        line-height: 36pt; /* 2 linhas da grade */\n        margin-top: 180pt; /* 10 linhas da grade */\n      }\n      .content-page h2.font-merriweather { \n        font-family: 'Merriweather', serif;\n        font-weight: 700;\n        font-size: 24pt;\n        line-height: 1.5; /* 36pt = 2 linhas da grade */\n        text-align: center;\n        color: rgba(51, 51, 51, 0.5);\n        margin-top: 36pt; /* 2 linhas de espaço acima */\n        margin-bottom: 54pt; /* 3 linhas de espaço abaixo */\n      }\n      .content-page h3.font-merriweather-sans { \n        font-family: 'Merriweather Sans', sans-serif;\n        font-weight: 800;\n        font-size: 14.4pt;\n        line-height: 1.25; /* 18pt = 1 linha da grade */\n        color: rgba(36, 36, 36, 0.75);\n        margin-top: 36pt; /* 2 linhas de espaço acima */\n        margin-bottom: 18pt; /* 1 linha de espaço abaixo */\n      }\n      .content-page p.font-merriweather { \n        font-size: 12pt;\n        line-height: 1.5; /* Ritmo da grade = 18pt */\n        font-weight: 300;\n        text-align: justify;\n        hyphens: auto;\n        orphans: 2;\n        widows: 2;\n        text-indent: 1cm;\n        margin-top: 0;\n        margin-bottom: 18pt;\n      }\n      .content-page h2 + p.font-merriweather,\n      .content-page h3 + p.font-merriweather {\n        text-indent: 0;\n      }\n    </style>\n  </head>`;\n};\n\n/**\n * Gera o HTML interno para uma única parte do livro (capa, capítulo, etc.).\n */\nconst getInnerHtmlForPart = (book: Book, part: BookPart): string => {\n    let content: any;\n    try {\n        content = JSON.parse(part.content);\n    } catch (e) {\n        // Fallback se o conteúdo não for um JSON válido\n        content = { title: (book as any).title, content: part.content };\n    }\n\n    switch (part.part_type) {\n        case 'cover':\n            const coverData = content;\n            const coverBgUrl = 'https://raw.githubusercontent.com/lidiabookmaker/lidia-app/main/public/fundo-light-lidia-cover.webp';\n            const logoUrl = 'https://raw.githubusercontent.com/lidiabookmaker/lidia-app/main/public/lidia-logo-trans.svg';\n\n            return `\n              <div class=\"page-container cover-page\" style=\"background-image: url('${coverBgUrl}');\">\n                  <h1 class=\"cover-element cover-title\">${coverData.title || book.title}</h1>\n                  <p class=\"cover-element cover-subtitle\">${coverData.subtitle || ''}</p>\n                  <p class=\"cover-element cover-author\">${book.author}</p>\n                  <img class=\"cover-element cover-logo\" src=\"${logoUrl}\" alt=\"Logo Lidia\">\n              </div>`;\n\n        case 'copyright':\n            const copyrightText = content.content || `Copyright © ${new Date().getFullYear()} ${book.author}`;\n            return `<div style=\"display: flex; flex-direction: column; justify-content: center; align-items: center; height: 180mm; text-align: center; font-size: 10pt;\"><p>${copyrightText}</p><p>Todos os direitos reservados.</p></div>`;\n\n        case 'toc':\n            const tocTitle = content.title || 'Sumário';\n            const tocContent = content.content || '';\n            return `<h2 class=\"font-merriweather\">${tocTitle}</h2>` + tocContent.split('\\n').map((line: string) => `<p class=\"font-merriweather\" style=\"text-indent: 0; text-align: left;\">${line}</p>`).join('');\n        \n        case 'introduction':\n             const introTitle = content.title || 'Introdução';\n             return `<h2 class=\"font-merriweather\">${introTitle}</h2>` + formatParagraphs(content.content);\n        \n        case 'chapter_title':\n            // Cria uma página de rosto dedicada para o título do capítulo\n            return `<div class=\"page-container chapter-title-page\"><h1 class=\"chapter-title-standalone\">${content.title}</h1></div>`;\n\n        case 'chapter_content':\n            let chapterHtml = '';\n            if (content.introduction) {\n              chapterHtml += formatParagraphs(content.introduction);\n            }\n            if (content.subchapters && Array.isArray(content.subchapters)) {\n              content.subchapters.forEach((sub: any) => {\n                  chapterHtml += `<h3 class=\"font-merriweather-sans\">${sub.title}</h3>`;\n                  chapterHtml += formatParagraphs(sub.content);\n              });\n            }\n            return chapterHtml;\n        \n        default:\n            return '';\n    }\n};\n\n/**\n * Monta o HTML para uma única parte, usado na geração de PDF incremental.\n * Esta função foi removida na nova versão, mas mantida aqui para referência se necessário.\n */\nexport const assemblePartHtml = (book: Book, part: BookPart): string => {\n  const innerHtml = getInnerHtmlForPart(book, part);\n  const head = getHeadContent(book);\n  \n  // A capa e as páginas de título já têm seu próprio container.\n  if (part.part_type === 'cover' || part.part_type === 'chapter_title') {\n    return `<!DOCTYPE html><html lang=\"pt-BR\">${head}<body>${innerHtml}</body></html>`;\n  }\n  \n  // Outras partes são envolvidas no container de conteúdo.\n  const body = `<div class=\"page-container content-page\">${innerHtml}</div>`;\n  return `<!DOCTYPE html><html lang=\"pt-BR\">${head}<body>${body}</body></html>`;\n};\n\n\n/**\n * Monta o HTML completo do livro, juntando todas as partes.\n */\nexport const assembleFullHtml = (book: Book, parts: BookPart[]): string => {\n  // Garante que as partes estão na ordem correta\n  parts.sort((a, b) => a.part_index - b.part_index);\n  \n  const head = getHeadContent(book);\n  \n  // Mapeia cada parte para seu próprio container, garantindo quebras de página corretas\n  const bodyContent = parts.map(part => {\n    const innerHtml = getInnerHtmlForPart(book, part);\n    \n    // A capa e as páginas de título de capítulo já retornam seu próprio container principal.\n    if (part.part_type === 'cover' || part.part_type === 'chapter_title') {\n      return innerHtml;\n    }\n    \n    // As outras partes são envolvidas em um container para controle de página e aplicação de estilos.\n    return `<div class=\"page-container content-page\">${innerHtml}</div>`;\n  }).join('\\n');\n\n  // Monta o documento final, incluindo o lang=\"pt-BR\" essencial para a hifenização.\n  return `<!DOCTYPE html>\n    <html lang=\"pt-BR\">\n    ${head}\n    <body>\n        ${bodyContent}\n    </body>\n    </html>`;\n};"
  },
  {
    "path": "services/bookGenerator.ts",
    "content": "\nimport { GoogleGenAI, Type } from \"@google/genai\";\nimport { supabase } from './supabase';\nimport type { UserProfile, BookGenerationFormData, BookPart } from '../types';\nimport { GEMINI_API_KEY } from './geminiConfig';\n\n// --- Types for the AI's expected JSON structure ---\ninterface SubChapter {\n  title: string;\n  content: string;\n}\ninterface Chapter {\n  title: string;\n  introduction: string;\n  subchapters: SubChapter[];\n}\ninterface DetailedBookContent {\n  optimized_title: string;\n  optimized_subtitle: string;\n  introduction: { title: string; content: string };\n  table_of_contents: { title: string; content: string; };\n  chapters: Chapter[];\n  conclusion: { title: string; content: string };\n}\n// --- End of Types ---\n\nconst bookSchema = {\n    type: Type.OBJECT,\n    properties: {\n        optimized_title: { type: Type.STRING, description: \"O título final otimizado para a capa, com no máximo 45 caracteres sem contar os espaços.\" },\n        optimized_subtitle: { type: Type.STRING, description: \"O subtítulo final otimizado para a capa, com no máximo 90 caracteres sem contar os espaços.\" },\n        introduction: { type: Type.OBJECT, properties: { title: { type: Type.STRING }, content: { type: Type.STRING } }, required: ['title', 'content'] },\n        table_of_contents: { type: Type.OBJECT, properties: { title: { type: Type.STRING }, content: { type: Type.STRING } }, required: ['title', 'content'] },\n        chapters: {\n            type: Type.ARRAY,\n            items: {\n                type: Type.OBJECT,\n                properties: {\n                    title: { type: Type.STRING },\n                    introduction: { type: Type.STRING },\n                    subchapters: {\n                        type: Type.ARRAY,\n                        items: {\n                            type: Type.OBJECT,\n                            properties: {\n                                title: { type: Type.STRING },\n                                content: { type: Type.STRING },\n                            },\n                            required: ['title', 'content']\n                        }\n                    }\n                },\n                required: ['title', 'introduction', 'subchapters']\n            }\n        },\n        conclusion: { type: Type.OBJECT, properties: { title: { type: Type.STRING }, content: { type: Type.STRING } }, required: ['title', 'content'] },\n    },\n    required: ['optimized_title', 'optimized_subtitle', 'introduction', 'table_of_contents', 'chapters', 'conclusion']\n};\n\n\nconst buildPrompt = (formData: BookGenerationFormData): string => {\n    return `\n      Por favor, crie o conteúdo completo para um livro digital com as seguintes especificações.\n      O formato da resposta DEVE ser um JSON válido que corresponda ao esquema fornecido.\n      NÃO inclua markdown (como \\\`\\\`\\\`json) na sua resposta. A resposta deve ser APENAS o JSON.\n\n      **Instruções Gerais de Conteúdo:**\n      - Para todos os campos de texto como 'content' e 'introduction', o texto DEVE ser dividido em múltiplos parágrafos para boa legibilidade. Use o caractere de nova linha (\\\\n) para separar os parágrafos dentro da string do JSON. Cada parágrafo deve ter um tamanho razoável, evitando \"paredes de texto\".\n\n      **Instruções para Título e Subtítulo:**\n      - **Sugestão de Título (do usuário):** \"${formData.title}\"\n      - **Sugestão de Subtítulo (do usuário):** \"${formData.subtitle}\"\n      - Crie um **Título Final Otimizado** para a capa. REGRAS: Máximo de 45 caracteres (sem contar espaços), impactante e divisível em 2-3 linhas. O campo no JSON DEVE ser \\\`optimized_title\\\`.\n      - Crie um **Subtítulo Final Otimizado** para a capa. REGRAS: Máximo de 90 caracteres (sem contar espaços). O campo no JSON DEVE ser \\\`optimized_subtitle\\\`.\n\n      **Outras Informações:**\n      **Autor:** ${formData.author}\n      **Idioma:** ${formData.language}\n      **Tom de voz:** ${formData.tone}\n      **Nicho/Assunto:** ${formData.niche}\n      **Resumo do conteúdo desejado:** ${formData.summary}\n      \n      **Estrutura e Contagem de Palavras (REGRAS OBRIGATÓRIAS):**\n      - **Introdução:** No mínimo 400 palavras, divididas em múltiplos parágrafos usando \\\\n. O título DEVE ser \"Introdução\".\n      - **Sumário:** O título DEVE ser \"Sumário\". O conteúdo deve ser APENAS a lista de todos os 10 capítulos e seus 3 subcapítulos, formatada como texto simples com quebras de linha. Exemplo: 'Capítulo 1: Título do Capítulo\\\\n- Subcapítulo 1.1\\\\n- Subcapítulo 1.2'. NÃO inclua nenhum parágrafo de introdução ou texto descritivo para o sumário.\n      - **Capítulos:** Crie exatamente 10 capítulos. O total de palavras por capítulo deve ser no mínimo 2100 palavras.\n        - **Introdução do Capítulo:** No mínimo 300 palavras, divididas em múltiplos parágrafos usando \\\\n.\n        - **Subcapítulos:** Crie exatamente 3 subcapítulos para cada capítulo.\n          - **Conteúdo de cada Subcapítulo:** No mínimo 600 palavras, divididas em múltiplos parágrafos usando \\\\n.\n      - **Conclusão:** No mínimo 600 palavras, divididas em múltiplos parágrafos usando \\\\n. O título DEVE ser \"Conclusão\".\n      \n      **Instruções Adicionais para Títulos de Capítulo:**\n      - Para o título de cada capítulo na estrutura JSON (\\\`chapters[].title\\\`), forneça APENAS o nome do capítulo (ex: \"Os Pilares da Alimentação Saudável\"), sem o prefixo numérico como \"Capítulo 1:\".\n\n      É CRUCIAL que o conteúdo total do livro atinja no mínimo 22.800 palavras. A IA deve expandir os tópicos com detalhes, exemplos e analogias para atingir este volume.\n    `;\n};\n\n/**\n * Orchestrates the entire book generation pipeline.\n * @param formData - The data submitted by the user.\n * @param user - The current user profile.\n * @param updateLog - A callback function to send real-time progress updates to the UI.\n * @returns The ID of the newly created book.\n */\nexport const generateBookContent = async (\n    formData: BookGenerationFormData,\n    user: UserProfile,\n    updateLog: (message: string) => void\n): Promise<string> => {\n    updateLog(\"Inicializando Lidia SNT® Core Inside . . .\");\n    const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });\n\n    const prompt = buildPrompt(formData);\n    updateLog(\"Prompt para Lidia criado . . .\");\n\n    updateLog(\"Enviando requisição para Lidia . . .\");\n    let response;\n    const modelsToTry: ('gemini-2.5-pro' | 'gemini-2.5-flash')[] = ['gemini-2.5-pro', 'gemini-2.5-flash'];\n      \n    for (const model of modelsToTry) {\n        try {\n            if (model === 'gemini-2.5-pro') {\n                updateLog(\"SNT® started in deep research, content planning, and simultaneous semantic writing intensive work.\");\n            } else {\n                updateLog(`Tentando com o modelo: ${model}...`);\n            }\n            \n            response = await ai.models.generateContent({\n                model: model,\n                contents: prompt,\n                config: {\n                    responseMimeType: \"application/json\",\n                    responseSchema: bookSchema\n                }\n            });\n            updateLog(`Sucesso com o modelo: ${model}.`);\n            break; \n        } catch (error) {\n            const err = error as Error;\n            // If it's the last model or the error is not 'overloaded', rethrow it.\n            if (model === modelsToTry[modelsToTry.length - 1] || !err.message.toLowerCase().includes('overloaded')) {\n                throw error;\n            }\n            updateLog(`Modelo ${model} sobrecarregado. Tentando o próximo modelo...`);\n        }\n    }\n\n    if (!response) {\n        throw new Error(\"Todos os modelos de IA falharam ou estão indisponíveis.\");\n    }\n\n    updateLog(\"Resposta da IA recebida e validada.\");\n\n    let jsonText = response.text.trim();\n    const bookContent: DetailedBookContent = JSON.parse(jsonText);\n    const finalTitle = bookContent.optimized_title;\n    const finalSubtitle = bookContent.optimized_subtitle;\n    updateLog(`Título otimizado pela IA: \"${finalTitle}\"`);\n    updateLog(`Subtítulo otimizado pela IA: \"${finalSubtitle}\"`);\n    \n    updateLog(\"Iniciando salvamento do livro no banco de dados...\");\n    const { data: newBook, error: bookError } = await supabase\n      .from('books')\n      .insert({\n          user_id: user.id,\n          title: finalTitle,\n          subtitle: finalSubtitle,\n          author: formData.author,\n          status: 'processing_parts', // New initial status\n      })\n      .select()\n      .single();\n  \n    if (bookError) throw bookError;\n    updateLog(`Registro principal do livro criado com ID: ${newBook.id}`);\n\n    const partsToInsert: Omit<BookPart, 'id'>[] = [];\n    let partIndex = 1;\n\n    // 1. Cover\n    partsToInsert.push({ book_id: newBook.id, part_index: partIndex++, part_type: 'cover', content: JSON.stringify({ title: finalTitle, subtitle: finalSubtitle, author: formData.author }) });\n    // 2. Copyright\n    partsToInsert.push({ book_id: newBook.id, part_index: partIndex++, part_type: 'copyright', content: JSON.stringify(`Copyright © ${new Date().getFullYear()} ${formData.author}`) });\n    // 3. Table of Contents\n    partsToInsert.push({ book_id: newBook.id, part_index: partIndex++, part_type: 'toc', content: JSON.stringify(bookContent.table_of_contents) });\n    // 4. Introduction\n    partsToInsert.push({ book_id: newBook.id, part_index: partIndex++, part_type: 'introduction', content: JSON.stringify(bookContent.introduction) });\n    // 5. Chapters (each chapter is broken into two parts: title and content)\n    bookContent.chapters.forEach(chapter => {\n        partsToInsert.push({ book_id: newBook.id, part_index: partIndex++, part_type: 'chapter_title', content: JSON.stringify({ title: chapter.title }) });\n        // The entire chapter object is saved as the content for the 'chapter_content' part\n        partsToInsert.push({ book_id: newBook.id, part_index: partIndex++, part_type: 'chapter_content', content: JSON.stringify(chapter) });\n    });\n    // 6. Conclusion\n    partsToInsert.push({ book_id: newBook.id, part_index: partIndex++, part_type: 'conclusion', content: JSON.stringify(bookContent.conclusion) });\n\n    updateLog(`Preparando ${partsToInsert.length} partes do livro para salvar...`);\n    const { error: partsError } = await supabase.from('book_parts').insert(partsToInsert);\n    if (partsError) throw partsError;\n    updateLog(\"Todas as partes do livro foram salvas com sucesso.\");\n\n    updateLog(\"Atualizando status final do livro...\");\n    const { error: updateStatusError } = await supabase.from('books').update({ status: 'content_ready' }).eq('id', newBook.id);\n    if(updateStatusError) throw updateStatusError;\n\n    const newCredits = user.book_credits - 1;\n    const { error: profileError } = await supabase\n      .from('profiles')\n      .update({ book_credits: newCredits })\n      .eq('id', user.id);\n    if (profileError) throw profileError;\n    updateLog(\"Créditos do usuário atualizados.\");\n\n    return newBook.id;\n};"
  },
  {
    "path": "supabase/functions/upload-final-pdf/index.ts",
    "content": "\n// supabase/functions/upload-final-pdf/index.ts\n\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2.44.4';\n\n// Standard CORS headers\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n};\n\n// Deno serverless function\nDeno.serve(async (req: Request) => {\n  // Handle CORS preflight requests\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders });\n  }\n\n  try {\n    // Ensure the request method is POST\n    if (req.method !== 'POST') {\n      return new Response(JSON.stringify({ error: 'Method Not Allowed' }), {\n        status: 405,\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n      });\n    }\n\n    // Initialize Supabase client using environment variables for admin access\n    const supabaseClient = createClient(\n      Deno.env.get('SUPABASE_URL')!,\n      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!\n    );\n\n    // Parse FormData from the incoming request\n    const formData = await req.formData();\n    const bookId = formData.get('bookId') as string;\n    const pdfFile = formData.get('pdf') as File;\n\n    // Validate that required form fields are present\n    if (!bookId || !pdfFile) {\n      return new Response(JSON.stringify({ error: 'Missing required fields: bookId or pdf' }), {\n        status: 400,\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n      });\n    }\n\n    const filePath = `${bookId}/final.pdf`;\n\n    // 1. Upload the PDF file to Supabase Storage\n    const { error: uploadError } = await supabaseClient.storage\n      .from('books')\n      .upload(filePath, pdfFile, {\n        contentType: 'application/pdf',\n        upsert: true, // Overwrite existing file if it exists\n      });\n\n    if (uploadError) {\n      console.error('Storage Upload Error:', uploadError);\n      throw uploadError;\n    }\n\n    // 2. Retrieve the public URL for the uploaded file\n    const { data: urlData } = supabaseClient.storage\n      .from('books')\n      .getPublicUrl(filePath);\n\n    if (!urlData || !urlData.publicUrl) {\n      throw new Error(\"Could not retrieve public URL for the uploaded file.\");\n    }\n    const publicUrl = urlData.publicUrl;\n\n    // 3. Update the 'pdf_final_url' column in the 'books' table\n    const { error: dbError } = await supabaseClient\n      .from('books')\n      .update({ pdf_final_url: publicUrl })\n      .eq('id', bookId);\n\n    if (dbError) {\n      console.error('Database Update Error:', dbError);\n      // Attempt to remove the uploaded file if the DB update fails to avoid orphaned files\n      await supabaseClient.storage.from('books').remove([filePath]);\n      throw dbError;\n    }\n\n    // 4. Return a successful response with the public URL\n    return new Response(JSON.stringify({ success: true, url: publicUrl }), {\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n      status: 200,\n    });\n\n  } catch (error) {\n    // Generic error handler for any failures in the try block\n    console.error('Function execution error:', error);\n    return new Response(JSON.stringify({ error: error.message }), {\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n      status: 500,\n    });\n  }\n});"
  }
]
